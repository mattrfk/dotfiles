#!/usr/bin/env python3

from requests   import get
from bs4        import BeautifulSoup
from sys        import argv
from os         import popen, path

base_url = "https://www.etymonline.com"
search_url = "/search?q="
cache = path.join(path.expanduser("~"), ".etymcache")

def check_cache(word):
    if not path.exists(cache): return False

    definition = ""
    with open(cache) as f:
        for l in f:
            # found the word, I don't want the first line
            # because the first line is just the word
            # so I write something else instead to trigger
            # the next if statement
            if l.strip() == word:
                definition += "cached definition:\n"
            elif definition:
                if "------" in l: break
                definition += l
                
    return definition

def put_cache(word, definition):
    """ cache the definition. Return False if the 
        cache file was not updated """ 
    if check_cache(word): return False
    with open(cache, "a") as f:
        #TODO: write date here? 
        f.write(word + '\n')
        f.write(definition)
        f.write('-' * 40 + '\n')
        return True

    return False # shouldn't get here.

def get_word():
    if len(argv) < 2:
        return input("Give me a word: ")
    return argv[1]

def get_soup(url):
    page = get(url)
    return BeautifulSoup(page.text, 'html.parser')

def is_word_class(a):
    """ return true if tag `a` has a class starting with `word` """

    c = a.get('class')
    if c and (c[0].startswith('word__name') or 
              c[0].startswith('word--')):
        return True
    return False

def wprint(s, width=False, indent=0):
    """ print string `s`, wrapped, by word, at column `width`
        and indented `indent` spaces"""

    text = ""

    if not width:
        cols = int(popen('stty size', 'r').read().split()[1])
        width = 40 if cols > 40 else cols

    words = s.split()
    lines = []
    t = []
    length = 0

    ind = lambda t: [" " * (indent -1)] + t

    for w in words:
        length += len(w) + 1 # add one for the space
        if length + indent > width: # start new line
            lines.append(ind(t) if indent else t)
            t = [w]
            length = 0
        else:
            t.append(w)

    if t: lines.append(ind(t) if indent else t) # include last line

    for line in lines:
        text += ' '.join(line)
        text += '\n'

    return text

def get_index(words, word):

    for i,w in enumerate(words):
        if word in w.text:
            return i

    for i,w in enumerate(words):
        print(f"{i+1:>2}) {w.text}")
    
    try:
        sel = input(f"Choose a word ({1}-{len(words)}): ")
    except KeyboardInterrupt: # e.g. C-c
        print()
        exit()

    index = int(sel) - 1
    if index < 0 or index > len(words) - 1:
        print("index out of range")
        return get_index(words)
    else:
        return index

# ask for a word or get it from command line argument 
word = get_word()

d = check_cache(word)
if d:
    print(d)
    exit()

# send request to etymonline and get list of search results
try:
    soup = get_soup(base_url + search_url + word)
except:
    print("Are you connected to the internet?")
    exit()

words = [a for a in soup('a') if is_word_class(a)]

if len(words) < 1:
    print("no words found for", word)
    exit()

# display results and ask which one to define
index = get_index(words, word)

# get definition page for selected word
link = base_url + words[index].get('href')
soup = get_soup(link)

content = [d for d in soup('div') if is_word_class(d)][0]

text = content.find('h1').get_text()
text += '\n'
text += len(text) * '='
text += '\n'

for p in content('p'):
    if len(p.get_text()) < 1: continue
    text += wprint(p.get_text())
    text += '\n'

for p in content('blockquote'):
    text += wprint(p.get_text(), indent=3)
    text += '\n'

text += '\n'
text += link
text += '\n'

print()
print(text)

if put_cache(word, text): print("chached", word)
